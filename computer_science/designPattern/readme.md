# 디자인 패턴과 패러다임

> 다양한 개발 도구의 기본이 되는 디자인 패턴과 어떠한 방식으로 로직을 구성해야 하는지에 대한 시각이 담겨있는 프로그래밍 패러다임에 대해 공부한 내용이다.

## 1. 디자인 패턴
> 디자인 패턴이란 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은 것이다.
- 패턴의 이름을 클릭하면 자세한 설명이 나온다.

### 1.1 [싱글톤 패턴](https://github.com/gudals-kim/Studyroom/blob/delevlop/computer_science/designPattern/docs/singleton.md)

- 하나의 클래스에 오직 하나의 객체만 가지는 패턴이다.
- 장점 : 객체 생성 비용이 줄어든다.
- 단점 : 의존성이 높아진다.
- 사용처 : 보통 데이터베이스 연결 모듈에 많이 사용된다.

### 1.2 [팩토리 패턴](https://github.com/gudals-kim/Studyroom/blob/delevlop/computer_science/designPattern/docs/factory.md)

- 객체의 생성을 캡슐화 하는 패턴이며, ```팩토리 메서드 패턴```과, ```추상 팩토리 패턴```으로 나누어 진다.
- 공통점 
  - 객체의 생성부를 캡슐화 하여 결합을 느슨하게하여 의존성을 낮춘다.
- 차이점
  - ```팩토리 메서드 패턴``` 
    - 상속을 통해 서브 클래스에서 팩토리 메소드를 오버라이딩하여 객체의 생성부를 구현
  - ```추상 팩토리 패턴```
    - 객체의 집합을 생성하기 위한 정의를 추상체에 위치시키고 하위의 구현체에서 세부적인 집합 생성 과정을 구현 (Fatory Method를 이용해 구현)
- 장점
  - 상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지게 된다.
  - 또한 상위 클래스에서는 객체 생성 방식을 알 필요가 없기 때문에 유연성이 증가된다.
  - 객체 생성 로직이 따로 떼어져 있기 때문에 유지보수성이 증가된다.
- 단점 
  - 클래스가 많아진다. (클래스 계층도 커질 수 있다.)

### 1.3 [전략 패턴](https://github.com/gudals-kim/Studyroom/blob/delevlop/computer_science/designPattern/docs/strate.md)
> 동일한 문제를 해결하는 여러 알고리즘 중에서 필요에 따라 적합한 알고리즘을 선택하여 사용할 수 있도록 하는 패턴입니다.
- 장점: 알고리즘을 자유롭게 바꿀 수 있고, 새로운 알고리즘을 쉽게 추가할 수 있습니다.
- 단점: 코드가 길어지거나 복잡해질 수 있고, 알고리즘 간에 통신 비용이 발생할 수 있습니다.

### 1.4 [옵저버](https://github.com/gudals-kim/Studyroom/blob/delevlop/computer_science/designPattern/docs/observer.md)
> 옵저버 패턴은 객체의 상태 변화를 관찰하는 관찰자들<br>
> 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴입니다.

- 장점
  - 실시간으로 한 객체의 변경사항을 다른 객체에 전파할 수 있다.
  - 느슨한 결합으로 시스템이 유연하고 객체간의 의존성을 제거할 수 있습니다.

- 단점
  - 너무 많이 사용하게 되면 상태 관리가 힘들 수 있다.
  - 데이터 배분에 문제가 생기면 자칫 큰 문제로 이어질 수 있습니다.

### 1.5 [프록시](https://github.com/gudals-kim/Studyroom/blob/delevlop/computer_science/designPattern/docs/proxy.md)
> 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴
- 장점
  - 사이즈가 큰 객체가 로딩되기 전에도 프록시를 통해 참조를 할 수 있다.
  - 실제 객체의 public, protected 메소드를 숨기고 인터페이스를 통해 노출시킬 수 있다.
  - 로컬에 있지 않고 떨어져있는 객체를 사용할 수 있다.
- 단점
  - 객체를 생성할 때 한 단계를 거치게 되므로, 빈번한 객체 생성이 필요한 경우 성능이 저하될 수 있다.
  - 프록시 내부에서 객체 생성을 위해 스레드가 생성, 동기화가 구현되어야 하는 경우 성능이 저하될 수 있다.
  - 로직이 난해해져 가독성이 떨어질 수 있다.
>```캐싱```<br>
> 캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 
> 다시 저 멀리 있는 원격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용하는 것을 말한다.
### 1.6 [이터레이터](https://github.com/gudals-kim/Studyroom/blob/delevlop/computer_science/designPattern/docs/iterator.md)
>이터레이터 패턴은 컬렉션의 구현 방법을 노출시키지 않고 그 안에 존재하는 모든 항목에 접근할 수 있도록 하는 패턴입니다. <br>
>이터레이터 패턴을 사용하면 컬렉션 내에 구현이 어떤지 몰라도 해당 객체에 접근해 반복 작업을 처리할 수 있습니다.

- 장점
  - 집합체 클래스의 응집도를 높여준다.
  - 집합체 내에서 어떤 식으로 일이 처리되는지 알 필요 없이, 집합체 안에 들어있는 모든 항목에 접근 할 수 있게 해준다.
  - 모든 항목에 일일이 접근하는 작업을 컬렉션 객체가 아닌 이터레이터 객체에서 맡게 된다.
- 단점
  - 단순한 순회를 구현하는 경우 클래스만 많아져 복잡도가 증가할 수 있다.
### 1.7 [노출모듈](https://github.com/gudals-kim/Studyroom/blob/delevlop/computer_science/designPattern/docs/revealingModule.md)
> 노출 모듈 패턴은 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴입니다.

- 장점
  - 개발자에게 깔끔한 접근 방법을 제공
  - private 데이터 제공
  - 함수와 변수를 지역화 가능
  - 명시적으로 public 메소드와 변수를 제공해 명시성을 높임
- 단점
  - private 메소드에 대해 함수 확장시 어려움 발생
  - private 메소드를 참조하는 public 메소드 수정이 어려움
### 1.8 [MVC/MVP/MVVM](https://github.com/gudals-kim/Studyroom/blob/delevlop/computer_science/designPattern/docs/mvc.md)