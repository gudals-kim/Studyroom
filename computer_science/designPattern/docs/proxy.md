# proxy pattern
> 일반적으로 프록시는 다른 무언가와 이어지는 인터페이스의 역할을 하는 클래스입니다. 프록시는 어떠한 것과도 인터페이스의 역할을 수행할 수 있습니다.
```
예를 들어, 용량이 큰 이미지와 글이 같이 있는 문서를 모니터 화면에 띄운다고 가정하였을때
이미지 파일은 용량이 크고 텍스트는 용량이 작아서 텍스트는 빠르게 나타나지만 그림은 조금 느리게 로딩되는 것을 보신적이 있으실겁니다.
만약 이렇게 처리가 안되고 이미지와 텍스트가 모두 로딩이 된 후에야 화면이 나온다면 사용자는 페이지가 로딩될때까지 의미없이 기다려야 합니다.
그러므로 먼저 로딩이 되는 텍스트라도 먼저 나오는게 좋습니다. 
이런 방식을 취하려면 텍스트 처리용 프로세서, 그림 처리용 프로세스를 별도로 운영하면 됩니다.
이런 구조를 갖도록 설계하는것이 바로 프록시 패턴입니다
```
## 🙌 요약
> 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴
- 장점
  - 사이즈가 큰 객체가 로딩되기 전에도 프록시를 통해 참조를 할 수 있다.
  - 실제 객체의 public, protected 메소드를 숨기고 인터페이스를 통해 노출시킬 수 있다.
  - 로컬에 있지 않고 떨어져있는 객체를 사용할 수 있다.
- 단점
  - 객체를 생성할 때 한 단계를 거치게 되므로, 빈번한 객체 생성이 필요한 경우 성능이 저하될 수 있다.
  - 프록시 내부에서 객체 생성을 위해 스레드가 생성, 동기화가 구현되어야 하는 경우 성능이 저하될 수 있다.
  - 로직이 난해해져 가독성이 떨어질 수 있다.
>```캐싱```<br>
> 캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 
> 다시 저 멀리 있는 원격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용하는 것을 말한다.



### 👍 왜 사용하는가?
- 사이즈가 큰 객체가 로딩되기 전에도 프록시를 통해 참조를 할 수 있다.
- 실제 객체의 public, protected 메소드를 숨기고 인터페이스를 통해 노출시킬 수 있다.
- 로컬에 있지 않고 떨어져있는 객체를 사용할 수 있다.
### 👀 언제 많이 사용하는가?
> 프록시 패턴은 다른 객체에 대한 접근을 제어하기 위한 용도로 사용됩니다. <br>
> 프록시 패턴은 원래 객체에 대한 접근을 제어하므로 당신의 요청이 원래 객체에 전달되기 전/후에 무언가를 수행할 수 있도록 합니다 

### 👎 단점도 있나?
- 객체를 생성할 때 한 단계를 거치게 되므로, 빈번한 객체 생성이 필요한 경우 성능이 저하될 수 있다.
- 프록시 내부에서 객체 생성을 위해 스레드가 생성, 동기화가 구현되어야 하는 경우 성능이 저하될 수 있다.
- 로직이 난해해져 가독성이 떨어질 수 있다.

## 프록시 서버
> 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 나타낸다.


### 프록시 서버로 쓰이는 NGINX
> nginx는 비동기 인벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버이며, 주로 Node.js 서버 앞단의 프록시 서버로 활용된다.

**_"Node.js의 버퍼 오버플로우 취약점을 예방하기 위해서 nginx를 프록시 서버로 앞단에 높고 Node.js를 뒤쪽에 놓는 것이 좋다." - Ryan Dahl_**

<img src="https://velog.velcdn.com/post-images/jeff0720/91343f60-eb33-11e8-b115-5df0fc60ff3a/ngnix.png">

> 이런 구조를 통해 익명 사용자가 직접적으로 서버에 접근하는 것을 차단하고, 간접적으로 한 단계를 더 거치게 만들어서 보안을 강화할 수 있다.<br>

- Nginx를 프록시 서버로 사용할 때의 ```장점```

  - ```로드 밸런싱```: Nginx는 클라이언트의 요청을 프록시 서버에 분산하기 위해 로드 밸런싱을 수행하여 성능, 확장성 및 신뢰성을 향상시킬 수 있습니다.
  - ```캐싱```: Nginx를 역방향 프록시로 사용하면 미리 렌더링된 버전의 페이지를 캐시하여 페이지 로드 시간을 단축할 수 있습니다.
  - ```SSL 터미네이션```: Nginx는 클라이언트와의 연결에 대한 SSL 끝점 역할을 할 수 있습니다.
  - ```압축```: 프록시 서버가 압축된 응답을 보내지 않는 경우 클라이언트로 보내기 전에 응답을 압축하도록 Nginx를 구성할 수 있습니다.
  - ```DDoS 공격 완화```: 수신 요청과 단일 IP 주소당 연결 수를 일반 사용자에게 일반적인 값으로 제한할 수 있습니다 

- ```단점```
  - 1.설정이 복잡하고 어려울 수 있다.
  - 2.성능이 저하될 수 있다. 

### 프록시 서버로 쓰이는 CloudFlare
> CloudFlare 는 전 세계적으로 분산된 서버가 있고 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 ```CDN 서비스```이다.<br>
> ```CDN(Content Delivery Network)``` 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크를 말한다.<br> 
> 이를 통해 사용자가 웹 서버로부터 콘텐츠를 다운로드하는시간을 줄인다.

<img src="https://bloggingden.com/wp-content/uploads/2016/11/how-does-cloudflare-work.png">

> 웹 서버 앞단에 프록시 서버로 두어 DDOS 공격 방어나 HTTPS 구축에 쓰인다.<br>
> 서비스를 배포한 이후 해외에서 무언가 의심스로운 트래픽이 많이 발생하면 이 때문에 많은 클라우드 서비스 비용이 발생할 수 있다.<br>
> 이떄 CloudFlare가 의심스로운 트래픽인지 먼저 판단하고 CAPTCHA 등을 기반으로 이를 일정 부분 막아주는 역할도 수행한다.

앞의 그림처럼 사용자, 클로러, 공격자가 자신의 웹 사이트에 접속하게 될 텐데, 이때 CloudFlare를 통해 공격자로부터 보호할 수 있다.

### CORS와 프론트엔드 프록시 서버
> CORS(Cross-Origin Resource Sharing)은 서버가 웹 브라우저에서 리소스를 로드할 때, 다른 ```오리진```을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘이다.<br>
> ```오리진``` : 프로토콜과 호스트 이름, 포트의 조합을 뜻한다. // https://gudals.com:12101/test 의 주소에서 ```오리진```은 https://gudals.com:12101 을 말한다.

<img src="https://velog.velcdn.com/images/seungchan__y/post/b8355f82-612a-4e84-ba55-c4e9e4086dad/image.png">

프론트엔드 개발 시 프론트엔드 서버를 만들어서 백엔드 서버와 통신할 때 주로 CORS 에러를 마주친다. <br>
이를 해결하기 위해서 프런트엔드에서 프록시 서버를 만들기도 한다. <br>

```
예를 들어 프런트엔드에서는 127.0.0.1:3000으로 테스팅을 하는데 
백엔드 서버는 127.0.0.1:12010이라면 포트번호가 다르기 때문에 CORS 에러가 나타난다.

이때 프록시 서버를 둬서 프런트엔드 서버에서 요청되는 오리진을 127.0.0.1:12010으로 바꾸는 것이다.

참고로 127.0.0.1이란 루프백 IP로, 본인 PC 서버의 IP를 뜻한다.
localhost나 127.0.0.1을 주소창에 입력하면 DNS를 거치지않고 바로 본인 PC 서버로 연결된다.
```

<img src="https://velog.velcdn.com/images/seungchan__y/post/89fddacb-af4d-41c9-ad4d-403f008425b3/image.png">

앞의 그림처럼 프런트엔드 서버 앞단에 프록시 서버를 놓아서 /api  요청은 user API, /api2 요청은 users API2에 요청할 수 있다.<br>
자연스럽게 CORS 에러 해결은 물론이며 다양한 API서버와의 통신도 매끄럽게 할 수 있다.