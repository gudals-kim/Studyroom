# mvc&mvp&mvvm pattern

## 🙌 요약
> ```MVC 패턴```은 모델(model), 뷰(View), 컨트롤러(controller)로 이루어진 디자인 패턴이다. <br>
> ```MVP 패턴```은 모델(model), 뷰(View), 프레젠터(presenter)로 이루어진 디자인 패턴이다. <br>
> ```MVVM 패턴```은 모델(model), 뷰(View), 뷰-모델(view model)로 이루어진 디자인 패턴이다. <br>

### 장점
- ```MVC```
  - Model과 View의 분리됨
  - 구현하기 가장 쉽고 단순함
  - 개발기간이 짧아짐
- ```mvp```
  - View와 Model 사이의 의존성이 높다는 것을 해결한다.
  - 유지보수성이 조금 더 증가한다.
- ```mvvm```
  1. 뷰가 데이터를 실시간으로 관찰한다. 
     - LiveData, 즉 Observable 패턴을 이용하기 때문에 데이터베이스를 관찰하고 자동으로 UI를 갱신한다. 
     - 직접 뷰를 바꾸어주는 번거로움도 없으며 데이터와 불일치할 확률이 줄어든다.
  2. 생명주기로부터 안전하다.
     - 뷰모델을 통해 데이터를 참조하기 때문에 액티비티/프래그먼트의 생명주기를 따르지 않는다. 
     - 화면전환과 같이 액티비티가 파괴된 후 재구성 되어도 뷰모델이 데이터를 홀드하고 있기 때문에 영향을 받지 않는다. 
     - 뷰가 활성화되어있을 경우에만 작동하기 때문에 불필요한 메모리 사용을 줄일 수 있다.
  3. 단위 테스트가 쉽다.
  4. UI를 별도의 코드 수정없이 재사용할 수 있다.
### 단점
- ```mvc```
  - MVC 패턴의 단점은 View와 Model 사이의 의존성이 높다.
  - 기본기능 설계를 위해 클래스들이 많이 필요하기 때문에 복잡할 수 있다.
  - 설계시간이 오래 걸리고 숙련된 개발자가 필요하다.
  - Model과 View의 완벽한 분리가 어렵다.
- ```mvp```
  - MVC보다 설계가 어렵고 코드가 훨신 복잡해진다.
- ```mvvm```
  - 설계가 어렵고, 간단한 처리를 해주어야 할 때에는 데이터바인딩의 추가적인 코딩이 필요해 코드량이 늘어날 수 있습니다.



### 👍 왜 사용하는가?

- ```MVC```
  - Model과 View의 분리됨
  - 구현하기 가장 쉽고 단순함
  - 개발기간이 짧아짐
- ```mvp```
  - View와 Model 사이의 의존성이 높다는 것을 해결한다.
  - 유지보수성이 조금 더 증가한다.
- ```mvvm```
  1. 뷰가 데이터를 실시간으로 관찰한다. 
     - LiveData, 즉 Observable 패턴을 이용하기 때문에 데이터베이스를 관찰하고 자동으로 UI를 갱신한다. 
     - 직접 뷰를 바꾸어주는 번거로움도 없으며 데이터와 불일치할 확률이 줄어든다.
  2. 생명주기로부터 안전하다.
     - 뷰모델을 통해 데이터를 참조하기 때문에 액티비티/프래그먼트의 생명주기를 따르지 않는다. 
     - 화면전환과 같이 액티비티가 파괴된 후 재구성 되어도 뷰모델이 데이터를 홀드하고 있기 때문에 영향을 받지 않는다. 
     - 뷰가 활성화되어있을 경우에만 작동하기 때문에 불필요한 메모리 사용을 줄일 수 있다.
  3. 단위 테스트가 쉽다.
  4. UI를 별도의 코드 수정없이 재사용할 수 있다.
### 👀 언제 많이 사용하는가?
> MVVM패턴을 가진 대표적인 프레임 워크로는 vue.js가 있다.

### 👎 단점도 있나?
- ```mvc```
  - MVC 패턴의 단점은 View와 Model 사이의 의존성이 높다.
  - 기본기능 설계를 위해 클래스들이 많이 필요하기 때문에 복잡할 수 있다.
  - 설계시간이 오래 걸리고 숙련된 개발자가 필요하다.
  - Model과 View의 완벽한 분리가 어렵다.
- ```mvp```
  - MVC보다 설계가 어렵고 코드가 훨신 복잡해진다.
- ```mvvm```
  - 설계가 어렵고, 간단한 처리를 해주어야 할 때에는 데이터바인딩의 추가적인 코딩이 필요해 코드량이 늘어날 수 있습니다.
## MVC 패턴
> MVC 패턴은 모델(model), 뷰(View), 컨트롤러(controller)로 이루어진 디자인 패턴이다.

<img src="http://daheenallwhite.github.io/assets/post-image/MVC.jpg" width="700px">

- 애플리케이션의 구성요소를 세가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에 집중해서 개발할 수 있다.
- 재사용성과 확장성이 용이하다는 장점이 있다.
- 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는 단점이 있다.

### model
> 모델은 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻한다.
```
예를 들어 사각형 모양의 박스안에 글자가 들어 있다면 그 사각형 모양의 박스 위치 정보,
글자 내용, 글자 위치, 글자 포멧(utf-8등) 에 관한 정보를 모두 가지고 있어야 합니다.
뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신합니다.
```

### view 
> 뷰는 inputbox, checkbox, textarea 등 사용자 인터페이스 요소를 나타낸다. 즉, 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻한다.
- 모델이 가지고 있는 정보를 따로 저장하지 않아야 하며 단순히 사각형 모양 등 화면에 표시하는 정보만 가지고 있어야 한다.

### controller
> 컨트롤러는 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당한다.
- 모델과 뷰의 생명주기도 관리하며, 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성요소에 해당 내용에 대해 알려준다.


## MVP 패턴
> MVP 패턴은 MVC 패턴으로 부터 파생되었으며 MVC에서 C에 해당하는 컨트롤러가 프레젠터로 교체된 패턴입니다.<br>
> MVP는 Presenter를 만들어 모델과 뷰를 분리해주고 Presenter를 통해 모델과 뷰를 소통하게 해주므로 코드가 더 깔끔해지고 유지보수 하기 좋게 해주는 효과가 생긴다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDPh0m%2FbtqxGj14qcS%2FV8GEi2y81INjUfKidWKkt1%2Fimg.png">

뷰와 프레젠터가 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지닌 디자인 패턴이다.
### model
> M은 MODEL로서 앱 사용되는 데이터와 그 데이터를 처리하는 부분이다. 
### view
> V는 VIEW로서 말 그대로 사용자들에게 보여지는 UI라고 할 수 있다. 뷰의 터치 이벤트, UI갱신만 담당한다.
### Presenter
> P는 Presenter로서(증여자) View에서 요청한 정보로 Model을 가공하여 View에 전달해 주는 부분이다. View와 Model을 붙여주는 접착제같은 역할을 한다. Presenter와 View가  1대1  관계가 된다


### 장점
- MVC구조와 비교하면 알 수 있듯이 뷰와 모델의 의존성이 사라진다.
### 단점
- View와 Model 사이의 의존성은 해결되었지만, View와 Presenter 사이의 의존성이 높아졌기 때문에 어플리케이션이 복잡해질 수록 View와 Presenter 사이의 의존성이 강해진다.

## MVVM 패턴
> MVVM 패턴은 MVC의 C에 해당하는 컨트롤러가 뷰모델로 바뀐 패턴이다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FHdZ7U%2FbtqBD1oyva8%2FjnIzKB4AZWaLwqPhCPNMk0%2Fimg.png">

```
예를 들어, 유저가 목록에 새로운 아이템을 추가했다.

MVC에서는 컨트롤러가 유저의 클릭 액션을 확인하고, 모델에 데이터를 갱신하도록 요청하고, 뷰에도 화면을 업데이트 하라고 요청을 해야한다. 
코딩하다 무언가 빠뜨리면, 때로는 DB만 갱신되고 화면은 갱신되지 않는 경우도 나타난다. 액티비티가 해야 할 역할이 많아 바쁘다.

MVVM에서도 뷰가 유저의 클릭 액션을 확인하지만, 뷰에서 곧바로 DB에 접근하지 않는다. 
말 그대로 ‘뷰’이기 때문에 UI를 갱신하는 역할에 충실하다. 대신 뷰모델을 참조하고, 뷰모델에서는 다시 모델에서 잘 정리된 데이터를 참조한다. 
또, 뷰는 뷰모델을 관찰(Observe) 한다. DB에 새로운 아이템을 추가한 후에 화면을 업데이트 하라고 직접 명령하지 않아도 된다. 
뷰에서는 이미 뷰모델을 관찰하고 있기 때문에 데이터의 변화를 알아차리고 자동으로 화면을 갱신한다.
```
### 장점
1. 뷰가 데이터를 실시간으로 관찰한다. 
   - LiveData, 즉 Observable 패턴을 이용하기 때문에 데이터베이스를 관찰하고 자동으로 UI를 갱신한다. 
   - 직접 뷰를 바꾸어주는 번거로움도 없으며 데이터와 불일치할 확률이 줄어든다.

2. 생명주기로부터 안전하다.
   - 뷰모델을 통해 데이터를 참조하기 때문에 액티비티/프래그먼트의 생명주기를 따르지 않는다. 
   - 화면전환과 같이 액티비티가 파괴된 후 재구성 되어도 뷰모델이 데이터를 홀드하고 있기 때문에 영향을 받지 않는다. 
   - 뷰가 활성화되어있을 경우에만 작동하기 때문에 불필요한 메모리 사용을 줄일 수 있다.

3. 단위 테스트가 쉽다.

4. UI를 별도의 코드 수정없이 재사용할 수 있다.

### 단점
> 설계가 어렵고, 간단한 처리를 해주어야 할 때에는 데이터바인딩의 추가적인 코딩이 필요해 코드량이 늘어난다.
