
# [백준 9251번 LCS](https://www.acmicpc.net/problem/9251)

## <img src="https://raw.githubusercontent.com/gudals-kim/Studyroom/0c61bf1ad9b6434ff624dbab4012654df8c92b01/codingtest/img/rank/gold_5.svg" width="20">  백준 9251번 LCS  


| 시간제한 | 메모리제한 | 정답비율 | 난이도  | 
|:----:|:-----:|:----:|:----:|
| 0.1초 | 256MB | 40%  | 골드5  |

---

### 문제

<br> LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.
<br> 
<br> 예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.




### 예제 입출력

#### 입력 조건
> 첫째 줄과 둘째 줄에 두 문자열이 주어진다.<br> 
> 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.<br>
#### 출력 조건
> 첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다. <br>
---
#### 예제 입력 1
```
ACAYKP
CAPCAK
```
#### 예제 출력 1
```
4
```

---


<br>

### 문제풀이 전략
- 문제 유형
  - DP, 문자열

* 두 수열이 주어졌을 때, 두 수열 모두의 부분이 되는 수열 중 가장 긴 것을 찾아야 합니다.
* 가장 긴 공통 부분 수열(LCS) 문제로 알려진 대표적인 동적 프로그래밍 문제이다.
* 두 수열의 길이가 N 미만일 때, 시간 복잡도 O(N^2)이내로 문제를 해결해야한다.

#### 문제풀이 핵심 아이디어
* 두 수열을 각각 X,Y라고 한다.
* D[i][j] = X[0...i]와 Y[0...j]의 공통 부분 수열의 최대 길이
* 두 문자열의 길이를 조금씩 늘려 가며 확인하여, 공통 부분 수열의 최대 길이를 계산한다.
* 점화식
  * D[i][j] = D[i-1][j-1]+1 (if X[i] = Y[j])
  * D[i][j] = max(D[i][j-1],D[i-1][j])(if X[i]!=Y[j])

* X="ACAYKP"이고, Y="CAPCAK" 일때,
  * 초기화(@=공집합)

|    @    |  C  |  A  |  P  |  C  |  A  |  K  |
|:-------:|:---:|:---:|:---:|:---:|:---:|:---:|
| ***@*** |  0  |  0  |  0  |  0  |  0  |  0  |
| ***A*** |  0  ||||||
| ***C*** |  0  ||||||
| ***A*** |  0  ||||||
| ***Y*** |  0  ||||||
| ***K*** |  0  ||||||
| ***P*** |  0  ||||||

> 값이 동일하다면 (D[i-1][j-1] + 1) 같지 않다면 D[i][j-1]과 D[i-1][j] 중에서 더 큰 값을 넣는다.
#### i=1 (A와 비교)
  - j=0(@)
    - 같지 않음 
  - j=1(C)
    - 같지 않음 MAX(D[1][1-1]=0,D[1-1][1]=0) = 0
  - j=2(A)
    - 같음 (D[0][2-1])+1 = 1
  - j=3(P)
    - 같지 않음 MAX(D[1][3-1]=1,D[1-1][3]=0) = 1
  - j=4(C)
    - 같지 않음 MAX(D[1][4-1]=1,D[1-1][4]=0) = 1
  - j=5(A)
    - 같지 않음 MAX(D[1][5-1]=1,D[1-1][5]=0) = 1
  - j=6(K)
    - 같지 않음 MAX(D[1][6-1]=1,D[1-1][6]=0) = 1

|    -    |  @  |  C  |  A  |  P  |  C  |  A  |  K  |
|:-------:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| ***@*** |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
| ***A*** |  0  |  0  |  1  |  1  |  1  |  1  |  1  |
| ***C*** |  0  |||||||
| ***A*** |  0  |||||||
| ***Y*** |  0  |||||||
| ***K*** |  0  |||||||
| ***P*** |  0  |||||||

#### i=2 (C와 비교)
  - j=0(@)
    - 같지 않음 
  - j=1(C)
    - 같음 D[2-1][1-1] + 1 = 1
  - j=2(A)
    - 같지 않음 MAX(D[2][2-1]=1,D[2-1][2]=1) = 2
  - j=3(P)
    - 같지 않음 MAX(D[2][3-1]=1,D[2-1][3]=1) = 2
  - j=4(C)
    - 같음 D[2-1][4-1] + 1 = 2
  - j=5(A)
    - 같지 않음 MAX(D[2][5-1]=1,D[2-1][5]=1) = 2
  - j=6(K)
    - 같지 않음 MAX(D[2][6-1]=1,D[2-1][6]=1) = 2

|    -    |  @  |  C  |  A  |  P  |  C  |  A  |  K  |
|:-------:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| ***@*** |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
| ***A*** |  0  |  0  |  1  |  1  |  1  |  1  |  1  |
| ***C*** |  0  |  1  |  2  |  2  |  2  |  2  |  2  |
| ***A*** |  0  |||||||
| ***Y*** |  0  |||||||
| ***K*** |  0  |||||||
| ***P*** |  0  |||||||

#### i=3 (A와 비교)
  - j=0(@)
    - 같지 않음 
  - j=1(C)
    - 같지 않음 MAX(D[3][1-1]=0,D[3-1][1]=1) = 1
  - j=2(A)
    - 같음 D[3-1][2-1] + 1 = 2
  - j=3(P)
    - 같지 않음 MAX(D[3][3-1]=2,D[3-1][3]=2) = 2
  - j=4(C)
    - 같지 않음 MAX(D[3][4-1]=2,D[3-1][4]=2) = 2
  - j=5(A)
    - 같음 D[3-1][5-1] + 1 = 3
  - j=6(K)
    - 같지 않음 MAX(D[3][6-1]=3,D[3-1][6]=2) = 3

|    -    |  @  |  C  |  A  |  P  |  C  |  A  |  K  |
|:-------:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| ***@*** |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
| ***A*** |  0  |  0  |  1  |  1  |  1  |  1  |  1  |
| ***C*** |  0  |  1  |  2  |  2  |  2  |  2  |  2  |
| ***A*** |  0  |  1  |  2  |  2  |  2  |  3  |  3  |
| ***Y*** |  0  |||||||
| ***K*** |  0  |||||||
| ***P*** |  0  |||||||

---

#### 모든 수행이 끝났을때 

|    -    |  @  |  C  |  A  |  P  |  C  |  A  |  K  |
|:-------:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| ***@*** |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
| ***A*** |  0  |  0  |  1  |  1  |  1  |  1  |  1  |
| ***C*** |  0  |  1  |  2  |  2  |  2  |  2  |  2  |
| ***A*** |  0  |  1  |  2  |  2  |  2  |  3  |  3  |
| ***Y*** |  0  |  1  |  2  |  2  |  2  |  3  |  3  |
| ***K*** |  0  |  1  |  2  |  2  |  2  |  3  |  4  |
| ***P*** |  0  |  1  |  2  |  3  |  3  |  3  |  4  |

### 답안 전체코드

```py
x = input()
y = input()
dp = [[0]*(len(y)+1) for _ in range(len(x)+1)]

for i in range(1, len(x)+1):
    for j in range(1, len(y)+1):
        if x[i-1]==y[j-1]:
            dp[i][j] = dp[i-1][j-1]+1
        else:
            dp[i][j] = max(dp[i][j-1], dp[i-1][j])
print(dp[len(x)][len(y)])
```
