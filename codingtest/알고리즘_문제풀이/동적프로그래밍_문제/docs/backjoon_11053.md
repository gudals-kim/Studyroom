
# [백준 11053번 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)

## <img src="https://raw.githubusercontent.com/gudals-kim/Studyroom/0c61bf1ad9b6434ff624dbab4012654df8c92b01/codingtest/img/rank/silver_2.svg" width="20">  백준 11053번 가장 긴 증가하는 부분 수열  


| 시간제한 | 메모리제한 | 정답비율 | 난이도 | 
|:----:|:-----:|:----:|:---:|
|  1초  | 256MB | 37%  | 실버2  |

---

### 문제

<br> 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.
<br> 

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {***10***, ***20***, 10, ***30***, 20, ***50***} 이고, 길이는 4이다.


### 예제 입출력

#### 입력 조건
> 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.<br> 
> 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)<br>
#### 출력 조건
> 첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다. <br>
---
#### 예제 입력 1
```
6
10 20 10 30 20 50
```
#### 예제 출력 1
```
4
```

---


<br>

### 문제풀이 전략
- 문제 유형
  - DP
* 가장 긴 증가하는 부분 수열(LIS) 문제는, 전형적인 동적 프로그래밍 문제이다.
* 수열의 크기가 N일 떄, 기본적인 동적 프로그래밍 알고리즘으로 O(N^2) 안에 해결 할 수 있다.

#### 문제풀이 핵심 아이디어
- D[i] = array[i]를 마지막 원소로 가지는 부분 수열의 최대 길이
- 모든 0<=j<i에 대하여, D[i] = max(D[i], D[j]+1) if array[j]<array[i]

* N=6일때, 예시 수열에 대하여 다음과 같이 계산 할 수 있다.
  - i가 1~5 의 경우에 j(1~5)로 비교한다.

| i/N  | 10  | 20  | 10  | 30  | 20  | 50  |
|:----:|:---:|:---:|:---:|:---:|:---:|:---:|
| 초기상태 |1|1|1|1|1|  1  |

* i=1일떄
  - array[j]가 array[i]보다 작다면 D[j]와 D[i]를 더하여 D[i]에 저장한다.

| i/N  | 10  | 20  | 10  | 30  | 20  | 50  |
|:----:|:---:|:---:|:---:|:---:|:---:|:---:|
| 초기상태 |1|  1  |1|1|1|  1  |
| i=1  |1|  2  |1|1|1|  1  |

* i=2일떄
  - array[j]가 array[i]보다 작다면 D[j]와 D[i]를 더하여 D[i]에 저장한다.

| i/N  | 10  | 20  | 10  | 30  | 20  | 50  |
|:----:|:---:|:---:|:---:|:---:|:---:|:---:|
| 초기상태 |1|  1  |1|1|1|  1  |
| i=1  |1|  2  |1|1|1|  1  |
| i=2  |1|  2  |1|1|1|  1  |

* i=3일떄
  - array[j]가 array[i]보다 작다면 D[j]와 D[i]를 더하여 D[i]에 저장한다.
  - array[0]일때 기준인 array[3] 보다 작다.
    - D[0]+1 = 2
  - array[1]일때 기준인 array[3] 보다 작다.
    - D[1]+1 = 3
  - array[2]일때 기준인 array[3] 보다 작다.
    - D[2]+1 = 2
  - 이 중 가장 큰값을 D[3]에 저장한다. 

| i/N  | 10  | 20  | 10  | 30  | 20  | 50  |
|:----:|:---:|:---:|:---:|:---:|:---:|:---:|
| 초기상태 |1|  1  |1|  1  |1|  1  |
| i=1  |1|  2  |1|  1  |1|  1  |
| i=2  |1|  2  |1|  1  |1|  1  |
| i=3  |1|  2  |1|  3  |1|  1  |

* i=4일떄

| i/N  | 10  | 20  | 10  | 30  | 20  | 50  |
|:----:|:---:|:---:|:---:|:---:|:---:|:---:|
| 초기상태 |1|  1  |1|  1  |  1  |  1  |
| i=1  |1|  2  |1|  1  |  1  |  1  |
| i=2  |1|  2  |1|  1  |  1  |  1  |
| i=3  |1|  2  |1|  3  |  1  |  1  |
| i=4  |1|  2  |1|  3  |  2  |  1  |

* i=5일떄

| i/N  | 10  | 20  | 10  | 30  | 20  | 50  |
|:----:|:---:|:---:|:---:|:---:|:---:|:---:|
| 초기상태 |1|  1  |1|  1  |  1  |  1  |
| i=1  |1|  2  |1|  1  |  1  |  1  |
| i=2  |1|  2  |1|  1  |  1  |  1  |
| i=3  |1|  2  |1|  3  |  1  |  1  |
| i=4  |1|  2  |1|  3  |  2  |  1  |
| i=5  |1|  2  |1|  3  |  2  |  4  |


### 답안 전체코드

```py
n = int(input())
array = list(map(int, input().split()))
dp = [1]*n
for i in range(1, n):
    for j in range(0, i):
        if array[j] < array[i]:
            dp[i] = max(dp[i], dp[j]+1)
print(max(dp))
```
