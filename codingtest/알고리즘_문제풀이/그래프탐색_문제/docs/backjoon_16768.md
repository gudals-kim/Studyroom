
# [백준 16768번 Mooyo Mooyo](https://www.acmicpc.net/problem/16768)

## <img src="https://raw.githubusercontent.com/gudals-kim/Studyroom/0c61bf1ad9b6434ff624dbab4012654df8c92b01/codingtest/img/rank/gold_4.svg" width="20">  백준 16768번 Mooyo Mooyo  


| 시간제한 | 메모리제한 | 정답비율 | 난이도 | 
|:----:|:-----:|:----:|:---:|
|  2초  | 512MB | 47%  | 골드4 |

---

### 문제
  

<br> 자유 시간이 많은 농부 John의 농장에 있는 소들은 종종 비디오 게임을 하며 시간을 보냅니다.
<br> 그들이 가장 좋아하는 것 중 하나는 Puyo Puyo라는 인기 있는 인간 비디오 게임을 기반으로 합니다. 
<br> 암소 버전은 물론 Mooyo Mooyo라고 불립니다.
<br> 
<br> Mooyo Mooyo 게임은 크고 좁은 그리드에서 진행됩니다.
<br> N 높이 (1 <= N <= 100)이다 N = 6, 너비가 10일때의 예시

```
0000000000
0000000300
0054000300
1054502230
2211122220
1111111223
```

<br> 각 셀은 비어 있거나(0으로 표시됨) 9가지 색상 중 하나의 건초 더미(문자 1..9로 표시됨)입니다.
<br> 중력으로 인해 건초더미가 아래로 떨어지므로 건초더미 아래에는 0 셀이 없습니다.
<br> 
<br> 두 개의 셀이 가로 또는 세로로 직접 인접하고 0이 아닌 동일한 색상을 갖는 경우 두 셀은 동일한 연결 영역에 속합니다.
<br> 연결된 지역이 적어도 K 셀, 건초더미가 모두 사라지고 0으로 변합니다.
<br>
<br> 이와 같이 연결된 영역이 동시에 여러 개 존재하면 모두 동시에 사라집니다.
<br> 그 후 중력으로 인해 건초더미가 아래로 떨어져 0이 된 결과 셀 중 일부를 채울 수 있습니다.
<br> 결과 구성에서 다시 적어도 크기의 연결된 영역이 있을 수 있습니다.
<br> K 세포. 그렇다면 그것들도 사라지고(동시에 그러한 영역이 여러 개 있는 경우) 중력이 나머지 셀을 아래로 끌어당기고 적어도 크기의 연결된 영역이 없을 때까지 프로세스가 반복됩니다.
<br> K 존재합니다.
<br> 
<br> Mooyo Mooyo 보드의 상태를 고려하여 이러한 작업이 발생한 후 보드의 최종 사진을 출력하십시오.


### 예제 입출력

#### 입력 조건
> 입력의 첫 줄에는 다음이 포함됩니다. <br> 
> N과 K(1 <= K <= 10N). 나머지 N 라인은 보드의 초기 상태를 지정합니다. 

#### 출력 조건
> 출력해주세요 최종 보드 상태의 그림을 설명하는 N줄. <br>
> 만약, 거의 최단 경로가 없는 경우에는 -1을 출력한다. <br>
---
#### 예제 입력 1
```
6 3
0000000000
0000000300
0054000300
1054502230
2211122220
1111111223
```
#### 예제 출력 1
```
0000000000
0000000000
0000000000
0000000000
1054000000
2254500000
```

---



<br>

### 문제풀이 전략
- 문제 유형
  - 그래프, bfs, dfs

- n = 높이 (너비는 10으로 고정)
- k = 같은것이 k개 일때 없어진다.
- n=6, k=3일때의 예시로 들어보면, 같은 숫자가 3개 이상이 이어질때 사라진다.
```
0000000000
0000000300
0054000300
1054502230
2211122220
1111111223


0000000000
0000000300
0054000300
1054500030
2200000000
0000000003


0000000000
0000000000
0000000000
0000000000
1054000300
2254500333


0000000000
0000000000
0000000000
0000000000
1054000000
2254500000
```
#### 문제풀이 핵심 아이디어

1. 주어진 데이터의 모든 좌표를 dfs로 조회해서 이어진 개수를 찾는다.
  - 얼마나이어지는지확인() 함수 
    - 0이 아니고 방문하지 않았을때 호출한다.
    - 위 아래 좌 우가 같은 값일때 그 좌표로 탐색를 이어간다.
    - 호출이 될때마다 count += 1 해준다.
2. 이어진 개수가 k개 이상인 좌표인 경우에 그 좌표의 그룹은 0으로 만든다.
  - dfs()함수
    - k개 이상으로 이어진 좌표에서만 호출한다.
    - 위 아래 좌 우 가 같은값이면 그 좌표를 0으로 바꾸어준다.
  - 더이상 dfs가 호출되지 않는다는건 k개 이상 이어진 좌표가 없다는 것이기 때문에 down함수를 호출한다.
3. 0으로 만들어졌으니, 값들을 밑으로 내려준다.
  - down함수
    - 열 단위로 0이 아닌 값들을 아래로 내리는 함수.
    - 0이 아니라면, lst에 값들을 다 넣고 그 자리는 0으로 만든다.
    - 열의 끝에서부터 시작해서 lst에 있는 원소를 pop()으로 넣는다.
### 답안 전체코드

```py
높이, 이수이상은사라짐 = map(int, input().split())
data = [list(input()) for _ in range(높이)]
인접좌표모음 = [(0,1),(0,-1),(-1,0),(1,0)]

def 얼마나이어지는지확인(현재좌표):
    count = 1
    check[현재좌표[0]][현재좌표[1]] = True
    for 인접좌표 in 인접좌표모음:
        이동좌표 = (현재좌표[0]+인접좌표[0], 현재좌표[1]+인접좌표[1])
        # 옆 건초더미가 없을 경우(조건에 벗어날 경우 넘어간다.) == 현 위치가 모서리인 경우임
        if 이동좌표[0] < 0 or 이동좌표[0] >= 높이 or 이동좌표[1] < 0 or 이동좌표[1] >= 10:
            continue
        if check[이동좌표[0]][이동좌표[1]] or data[현재좌표[0]][현재좌표[1]] != data[이동좌표[0]][이동좌표[1]]:
            #이미 이동한 곳이거나 인접 건초더미가 같은값이 아니라면 넘어간다.
            continue
        #위 경우를 제외한 모든 경우는 옆 건초더미에 가야함
        count += 얼마나이어지는지확인(이동좌표)
    return count

def dfs(현재좌표, 색상):
    check2[현재좌표[0]][현재좌표[1]] = True
    data[현재좌표[0]][현재좌표[1]] = '0'
    for 인접좌표 in 인접좌표모음:
        이동좌표 = (현재좌표[0]+인접좌표[0], 현재좌표[1]+인접좌표[1])
        if 이동좌표[0] < 0 or 이동좌표[0] >= 높이 or 이동좌표[1] < 0 or 이동좌표[1] >= 10:
            continue
        if check2[이동좌표[0]][이동좌표[1]] or data[이동좌표[0]][이동좌표[1]] != 색상:
            continue
        dfs(이동좌표, 색상)

def down():
    for i in range(10):
        lst = []
        for j in range(높이):
            if data[j][i] != '0':
                lst.append(data[j][i])
                data[j][i] = '0'
        for 이수이상은사라짐 in range(높이-1, 0, -1):
            if lst:
                data[이수이상은사라짐][i] = lst.pop()
계속돌까 = True
while 계속돌까:
    계속돌까 = False
    check = [[False for i in range(10)] for _ in range(높이)]
    check2 = [[False for i in range(10)] for _ in range(높이)]
    for 높이좌표 in range(높이):
        for 넓이좌표 in range(10):
            if data[높이좌표][넓이좌표] =='0' or check[높이좌표][넓이좌표]:
                continue
            이어진개수 = 얼마나이어지는지확인((높이좌표,넓이좌표))
            if 이어진개수 >= 이수이상은사라짐:
                dfs((높이좌표,넓이좌표), data[높이좌표][넓이좌표])
                계속돌까 = True
    down()
for i in data:
    print(''.join(i))
```