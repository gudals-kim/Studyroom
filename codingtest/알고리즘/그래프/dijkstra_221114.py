import heapq


def dijkstra(그래프, 시작노드, 도착노드):
    최단거리저장 = {노드: [float('inf'), 시작노드] for 노드 in 그래프}
    최단거리저장[시작노드] = [0,시작노드]

    최소힙 = []
    heapq.heappush(최소힙, [최단거리저장[시작노드][0], 시작노드])

    while 최소힙:
        현재노드까지의최단거리, 현재노드 = heapq.heappop(최소힙)
        # 최단거리에 저장된 거리가 더 짧다면 수행 필요없음
        if 최단거리저장[현재노드][0] < 현재노드까지의최단거리:
            continue
        for 다음노드, 현재노드와다음노드의거리 in 그래프[현재노드].items():
            다음노드까지의최단거리 = 현재노드와다음노드의거리 + 현재노드까지의최단거리
            if 다음노드까지의최단거리 < 최단거리저장[다음노드][0]:
                최단거리저장[다음노드] = [다음노드까지의최단거리, 현재노드]
                heapq.heappush(최소힙, [다음노드까지의최단거리, 다음노드])

    경로 = [도착노드]
    역추적노드 = 도착노드
    while 최단거리저장[역추적노드][1] != 시작노드:
        경로.append(최단거리저장[역추적노드][1])
        역추적노드 = 최단거리저장[역추적노드][1]
    경로.append(시작노드)
    경로 = list(reversed(경로))
    return 최단거리저장, 경로

#test code
graph = {
    'A': {'B': 8,'C': 1,'D': 2},
    'B': {},
    'C': {'B': 5,'D': 2},
    'D': {'E': 3,'F': 5},
    'E': {'F': 1},
    'F': {'A': 5}
}

최단거리테이블,경로 = dijkstra(graph,'A','F')
print(f"최단거리테이블 = {최단거리테이블}, 경로 = {경로} ")


